<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset='utf-8'>
    <title>EditContext API</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c' defer class='remove'></script>
    <script class='remove'>
        var respecConfig = {
            github: "w3c/edit-context"
            ,specStatus:   "ED"
            ,shortName:    "edit-context"
            ,editors:      [{ name: "Shih-ling Keng",
                               mailto: "shihken@microsoft.com",
                               company: "Microsoft",
                               w3cid: 126951},
                               { name: "Anupam Snigdha",
                               mailto: "snianu@microsoft.com",
                               company: "Microsoft",
                               w3cid: 126950},
                               { name: "Bo Cupp",
                               mailto: "pcupp@microsoft.com",
                               company: "Microsoft",
                               w3cid: 126951},]
          ,   wgPublicList: "public-editing-tf"
	  ,   otherLinks: [{
                  key: 'Participate',
                  data: [{
                      value: 'We are on GitHub.',
                      href: 'https://github.com/w3c/edit-context'
                  }, {
                      value: 'File a bug.',
                      href: 'https://github.com/w3c/edit-context/issues'
                  }, {
                      value: 'Commit history.',
                      href: 'https://github.com/w3c/edit-context/commits/gh-pages'
                  }, {
                      value: 'Mailing list.',
                      href: 'http://lists.w3.org/Archives/Public/public-editing-tf/'
                  }]
              }]
          ,   group: "webediting"
          ,   edDraftURI:   "https://w3c.github.io/edit-context/"
          , xref: ["WebIDL"
          , "DOM"
          , "HTML"
          , "geometry-1"]
        };
    </script>
</head>

<body>
    <section id='abstract'>
        <p>The {{EditContext}} is a new API that allows authors to more directly participate in the text input process.
        </p>
    </section>
    <section id='sotd'>
      <p>
      </p>
    </section>
    <section class="informative">
        <h2>Introduction</h2>
        <section id="background">
            <h3>Background and Motivation</h3>
            <p>Modern operating systems provide mechanisms to produce text in a variety of ways: speech-to-text, virtual keyboards, handwriting recognition and many more.  When an app wants to consume text input from these various sources, it must first provide a view of its currently editable text to the operating system.  The view of editable text provides a common language that apps (having a variety of different document models) and sources of text (having a variety of different input methods) can both understand.  Both the apps and input sources communicate with one another by expressing their desired changes to the state of the common view as an event that the other can handle to facilitate the text input process.</p>
            <p>For the purposes of this document, a producer of text is known as a <dfn>Text Input Method</dfn>.  The view provided by an app which wants to consume text is called a <dfn>Text Edit Context</dfn>.  The service provided by the OS to facilitate the editing of text in the [=Text Edit Context=] by the [=Text Input Methods=] is called a <dfn>Text Input Service</dfn>.</p>
            <figure id="many-input-methods">
                <img src="images/many-input-methods.jpg" alt="">
                <figcaption>Many [=Text Input Methods=] using a [=Text Input Service=] to communicate with many apps through their [=Text Edit Contexts=].</figcaption>
            </figure>
            <p>Here’s a typical flow for the text input process in more detail:</p>
            <ol>
                <li>A user places focus into an editable region of the app.</li>
                <li>The app produces a [=Text Edit Context=] describing its editable region according to the standards set forth by the [=Text Input Service=] and provides that [=Text Edit Context=] to the [=Text Input Service=].</li>
                <li>The [=Text Input Service=] triggers a [=Text Input Method=] to provide some user interface for capturing text input from the user and provides the [=Text Input Method=] the app generated [=Text Edit Context=].</li>
                <li>The [=Text Input Method=] reads the location of selection and nearby text from the [=Text Edit Context=] to help tailor its user experience.</li>
                <li>The [=Text Input Method=] may also read screen coordinates for where the selection and editable region are located so that it can properly position its user interface next to the text being edited.</li>
                <li>The user interacts with the [=Text Input Method=] user interface to input text in some [=Text Input Method=]-specific way.</li>
                <li>The [=Text Input Method=] describes its desired modifications to the text and selection in the [=Text Edit Context=] in response to the user’s input.</li>
                <li>The app handles an event describing the desired modifications to its [=Text Edit Context=] and renders the result to the user.</li>
            </ol>
            <figure id="text-input-process">
                <img src="images/text-input-process.jpg" alt="">
                <figcaption>A sequence diagram illustrating a typical flow for text input.</figcaption>
            </figure>
            <p>Existing user agents handle the details of this text input process so that the author’s responsibility ends at declaring what elements of the document represent an editable region.  Authors express which regions are editable using input elements, textarea elements, contenteditable elements, or by setting the designMode attribute to true to mark an entire document as editable. </p>
            <p>As an editable region of the document is focused, the user agent automatically produces the [=Text Edit Context=] from the contents of the editable region and the position of the selection within it.  When a [=Text Input Method=] produces text, the user agent translates the events against its [=Text Edit Context=] into a set of DOM and style modifications – only some of which are described using existing events that an author can handle. </p>
            <p>Authors that want to produce sophisticated editing experiences may be challenged by the current approach.  If, for example, the text and selection are rendered to a canvas, user agents are unable to produce a [=Text Edit Context=] to drive the text input process.  Authors compensate by resorting to offscreen editable elements, but this approach comes with negative implications for accessibility, it deteriorates the input experience, and requires complex code to synchronize the position of the text in the offscreen editable element with the corresponding text in the canvas. </p>
            <p>With the introduction of this EditContext API, authors can more directly participate in the protocol for text input and avoid the pitfalls described above.</p>
        </section>
        <section id="editcontext-model">
            <h3>The EditContext Model</h3>
            
            <p>An {{EditContext}} has a [=text=], a [=selection start=] position, a [=selection end=] position, a [=composition start=] position,  a [=composition end=] position, a [=is composing=] flag, a [=control bounds=], a [=selection bounds=], an [=array of character bounds=] and a [=character bounds range start=] index.
            <p>The <dfn>text</dfn> consists of the plain text of the editable content. The initial value is the empty string.</p>
            <p>The <dfn>selection start</dfn> position is the start position of the current selection. The initial value is 0.</p>
            <p>The <dfn>selection end</dfn> position is the end position of the current selection. The initial value is 0.</p>
            <p>The <dfn>composition start</dfn> position is the start of the current composition. The initial value is 0</p>
            <p>The <dfn>composition end</dfn> position is the end of the current composition. The initial value is 0</p>
            <p>The <dfn>is composing</dfn> flag indicates if there is an active composition. The initial value is false</p>
            <p>The <dfn>control bounds</dfn> is the bounding box of the display surface. It is in the [=client coordinate=] and the initial x, y, width, and height are 0, 0, 0, and 0, respectively.</p>
            <p>The <dfn>selection bounds</dfn> is the bounding box of the selection. It is in the [=client coordinate=] and the initial x, y, width, and height are 0, 0, 0, 0, respectively.</p>
            <p>The <dfn>array of character bounds</dfn> consists of the bounding boxes of the rendering result of the characters in a substring of [=text=]. These bounding boxes are used by the [=Text Input Method=] to properly position its user interface. The bounding boxes are in [=client coordinate=] and the array is initially empty.</p>
            <p>The <dfn>character bounds range start</dfn> index is the index in the [=text=] for the first character of the [=array of character bounds=]. The inital value is 0.</p>

            <p>Associating an {{EditContext}} to an element makes that element intrinsically [=focusable=].  When the element is focused, the user agent will use the state of the {{EditContext}} to construct a [=Text Edit Context=] that is provided to the [=Text Input Service=] of the OS:</p>
            <ol>
              <li>Instead of deriving the text content of the [=Text Edit Context=] from the DOM, it will be taken from [=edit context=]'s [=text=].</li>
              <li>Instead of deriving the location of selection within that text from the document’s selection, the user agent will use [=edit context=]'s [=selection range=].</li>
              <li>Instead of querying the DOM’s associated CSS boxes for the size and position of selection, character bounds, and the editable region of the document, the user agent will use [=edit context=]'s [=selection bounds=], [=character bounds=], and [=control bounds=] respectively.</li>
            </ol>

            <p>Using an {{EditContext}}, an author can mark a region of the document [=editable=] by associating an {{EditContext}} object with an element as shown in the example below: </p>
            <aside class="example" title="Associate an EditContext with an Element">
                <pre><xmp><script type="module"> 
    let canvas = document.querySelector("canvas") 
    canvas.editContext = new EditContext() 
    // When the associated element is focused, the EditContext is automatically activated.
    canvas.focus();
</script>
<canvas></canvas></xmp></pre></aside>

            <p>In the example below, the author is using a canvas to draw an editable region that allows the user to input a single line of text rendered with a monospace font.  The text for the editable region is maintained by the author as a String.  The text offsets for the selection in the editable region are maintained by the author as a pair of Numbers: selectionStart and selectionEnd.  The Numbers refer to the count of the number of UTF-16 codepoints to the left of the start and end of the selection respectively.  For the sake of communicating the bounding boxes for the current selection and the editable region of the document to Text Input Services, the author also computes the bounding rectangle in CSS pixels for the selection and the editable region of the document. The offset of the rectangle is expressed relative to the origin of the canvas element since that is the element to which the author has associated an EditContext. Since the model for the author’s representation of text and selection location matches the form expected by the EditContext API, the author can simply assign those properties to the EditContext associated with the canvas whenever those values change. </p>

            <aside class="example" title="Using EditContext with editing model, view, and controller">
                <pre><xmp><script type="module">
    // This example is built on top of example 1.
    // Only the added logic is shown here for brevity.
    class EditingModel {
        constructor(text, selectionStart, selectionEnd, compositionStart, compositionEnd) {
            this.text = text  
            this.selectionStart = selectionStart
            this.selectionEnd = selectionEnd
            this.compositionStart = compositionStart
            this.compositionEnd = compositionEnd
        }  
    }  

    class EditingView {  
        constructor(canvas, model) {  
            this.canvas = canvas 
            this.model = model 
        } 

        render() {
            // render the text
            let canvasContext2D = this.canvas.getContext("2d");
            canvasContext2D.strokeText(this.model.text);

            // render the selection (implementation omitted for brevity)
        } 

        computeSelectionBound() { 
            // implementation omitted for brevity 
        } 

        computeControlBound() { 
            // implementation omitted for brevity 
        } 
    }

    class EditingController {
        constructor(model, view, editContext) {  
            this.view = view
            this.model = model
            this.editContext = editContext
        }

        render() {
            view.render()

            // keep EditContext in sync, which essentially means
            // rendering the plain text view of the model.
            let editContext = this.canvas.editContext  
            this.editContext.updateText(0, this.model.text.length, this.model.text)
            this.editContext.updateSelection(this.model.selectionStart, this.model.selectionEnd)

            let selectionBounds = view.computeSelectionBound()  
            let controlBounds = view.computeControlBound()  

            // These bounds have x, y, width and height members  
            // so they can be assigned directly to EditContext.
            editContext.updateSelectionBounds(selectionBounds)
            editContext.updateControlBoundss(controlBounds)
        }
    }

    let canvas = document.querySelector("canvas")
    canvas.editContext = new EditContext()
    let editingModel = new EditingModel("", 0, 0, 0, 0)
    let editingView = new EditingView(canvas, editingModel)
    let editingController = new EditingController(editingModel,
        editingView, canvas.editContext);

    editingController.render() 
</script>
<canvas></canvas></xmp></pre>
            </aside>

            <p>Building on the previous example, in response to user input, authors should handle the events of both the editable element (in this case a canvas) and the EditContext.</p>
            
            <p>Input events against the DOM continue to describe the user’s intent</p>
            
            <p>Against the EditContext, {{TextUpdateEvent}} describes changes to the text, the selection, and the composition range properties of the EditContext. {{TextFormatUpdateEvent}} describes changes to the style of the text. The updates received by the author’s code for text, selection, style, composition range changes should be rendered back to the canvas so the user can see what they are typing. {{CharacterBoundsUpdateEvent}} describes what character bounds are needed by the [=Text Input Service=] to support [=Text Input Method=] to properly display its user interface. After receiving {{CharacterBoundsUpdateEvent}}, the author is responsible to compute the requested character bounds and call {{EditContext/updateCharacterBounds}} to update the character bounds cached in the EditContext.</p>
            
            <p>Below example shows how to handle {{TextUpdateEvent}}, {{TextFormatUpdateEvent}}, and {{CharacterBoundsUpdateEvent}} to update the model and render the result to the canvas.</p>
            <aside class="example" title="Event handlers for TextUpdateEvent, TextFormatUpdateEvent, and CharacterBoundsUpdateEvent">
                <pre><xmp><script>
    // This example is built on top of example 1 and example 2.
    // Only the added logic is shown here for brevity.
    class EditingModel {
        updateText(updateRangeStart, updateRangeEnd, updateText) {
            this.text = this.text.substring(0, updateRangeStart) + updateText
                        + this.text.substring(updateRangeEnd)
        }

        updateSelection(selectionStart, selectionEnd) {
            this.selectionStart = selectionStart
            this.selectionEnd = selectionEnd
        }

        updateCompositionRange(compositionStart, compositionEnd) {
            this.compositionStart = compositionStart
            this.compositionEnd = compositionEnd
        }

        updateTextFormats(textFormats) {
            this.textFormats = textFormats
        }
    }

    class EditingView {
        render() {
            // render the text (implementation omitted for brevity)

            // render the selection (implementation omitted for brevity)

            // render the IME decoration
            this.model.textFormats.forEach( textFormat => {
                // For brevity, these variables' initialization are omitted:
                // anchorX: the x coordinate of the beginning of the string
                // lineY: the y coordinate of the underline
                // charWidth: the width of the character (here we are using a mono-spaced font)
                // thickWidth/thinWidth: pre-defined width for thick/thin lines.
                let lineStartX = anchorX + textFormat.rangeStart * charWidth;
                let lineEndX = anchorX + textFormat.rangeEnd * charWidth;
                
                canvasContext2D.lineWidth = (textFormat.underlineThickness == 'Thick')?
                                            thickWidth : thinWidth;
                canvasContext2D.beginPath();
                canvasContext2D.moveTo(lineStartX, lineY);
                canvasContext2D.lineTo(lineEndX, lineY);
                canvasContext2D.stroke();
            })
        }

        computeCharacterBounds(rangeStart, rangeEnd) {
            // implementation omitted for brevity
        }
    }

    class EditingController {
        handleTextUpdate(updateRangeStart, updateRangeEnd, updateText, 
                         newSelectionStart, newSelectionEnd,
                         compositionStart, compositionEnd) {
            this.model.updateText(updateRangeStart, updateRangeEnd, updatetext)
            this.model.updateSelection(newSelectionStart, newSelectionEnd)
            this.model.updateCompositionRange(compositionStart, compositionEnd)
        }

        handleTextFormatUpdate(textFormats) {
            this.model.updateTextFormats(textFormats);
        }

        handleCharacterBoundsUpdate(rangeStart, rangeEnd) {
            characterBounds = this.view.computeCharacterBounds(rangeStart, rangeEnd);
            this.editContext.updateCharacterBounds(rangeStart, characterBounds);
        }
    }

    // When user typing, EditContext will receive textupdate events,
    // which can be used to update the editor's model.
    editContext.addEventListener("textupdate", e => {
        editingController.handleTextUpdate(e.updateRangeStart, e.updateRangeEnd, e.updatetext,
                                        e.newSelectionStart, e.newSelectionEnd,
                                        e.compositionStart, e.compositionEnd)
    });

    // EditContext will also receive textformatupdate event for IME decoration.
    // Ex. thin/thick underline for the "phrase mode" in Japanese IME.
    editContext.addEventListener("textformatupdate", e => {
        editingcontroller.handleTextFormatUpdate(e.getTextFormats());
    });

    // When receiving CharacterBoundsUpdate event, the author is responsible to compute
    // the bounds of characters from rangeStart to rangeEnd, and call
    // EditContext.updateCharacterBounds to update the character bounds in EditContext.
    editContext.addEventListener("characterboundsupdate", e => {
        editingcontroller.handleCharacterBoundsUpdate(e.rangeStart, e.rangeEnd);
    });
</script></xmp></pre>
            </aside>

        </section>
        <section id="interactions">
            <h3>Interactions with Other Editing Primitives </h3>
            <p>An author doesn’t have to use a canvas element with an EditContext.  In the example below the author uses a div to establish an editable region of the document and renders the contents into that editable region using various other styled elements, images and text.  This allows the author to leverage other built-in editing primitives from the user agent such as selection and spellcheck. </p>

            <aside class="example" title="How native selection can be leveraged to handle caret navigation.">
                <pre><xmp><div></div>
<script>
    // This example reuses EditModel and EditController in Example 2 and 3.
    let div = document.querySelector("div") 
    div.editContext = new EditContext() 
    div.focus();

    class EditingView {  
        constructor(div, model) {  
            this.div = div 
            this.model = model 
        } 

        render() {
            // render the text
            this.div.innerText = this.model.text

            // render the selection (implementation omitted for brevity)
        }

        computeSelectionBound() { 
            // implementation omitted for brevity 
        } 

        computeControlBound() { 
            // implementation omitted for brevity 
        } 

        computeCharacterBounds(rangeStart, rangeEnd) {
            // implementation omitted for brevity
        }
    }

    class EditingController {
        handleSelectionChange() {
            // Authors are responsible to map the selection from the DOM space to the
            // plain text space. One approach is to use range.toString() to get the plain text
            // before the selection start/end, and use the text length as the selection index.
            let s = document.getSelection()
            let range = new Range()
            range.setEnd(s.anchorNode, s.anchorOffset)
            range.setStartBefore(parentContainer)
            let selectionStart = range.toString().length

            range.setEnd(s.focusNode, s.focusOffset)
            range.setStartBefore(parentContainer)
            let selectionEnd = range.toString().length

            // Update model
            this.model.updateSelection(selectionStart, selectionEnd)

            this.render()
        }
    }

    document.addEventListener("selectionchange", e => {
        editingController.handleSelectionChange()
    });
</script></xmp></pre>
            </aside>

            <aside class="example" title="How beforeinput can be used to catch insertReplacementText to apply spelling changes">
                <pre><xmp><script>
    // This example is built on top of example 4.
    // Only the added logic is shown here for brevity.
    class EditingController {
        handleSpellCheck(newText, range) {
            let updateRangeStart = range.startOffset
            let updateRangeEnd = range.endOffset

            // Update model
            this.model.updateText(updateRangeStart, updateRangeEnd, newText)
            let newCaretPosition = updateRangeStart + newText.length
            this.model.updateSelection(newCaretPosition, newCaretPosition)

            this.render()
        }
    }

    div.spellcheck = true;
    div.addEventListener("beforeinput", e => {
        if (e.inputType === "insertReplacementText") { // for spellcheck
            let newText = e.dataTransfer.getData("text");
            let range = e.getTargetRanges()[0];
            editingController.handleSpellCheck(newText, range)
        }
    })
</script></xmp></pre>
            </aside>

            <aside class="example" title="How beforeinput can be used to catch deleteByDrag and insertFromDrop to apply drag and drop changes">
                <pre><xmp><script>
    // This example is built on top of example 4.
    // Only the added logic is shown here for brevity.
    class EditingController {
        handleDeleteByDrag() {
            // Update model
            this.model.updateText(this.model.selectionStart, this.model.selectionEnd, "")

            this.render()
        }

        handleInsertFromDrop(newText, caretPosition) {
            // Update model
            editingModel.updateText(caretPosition, caretPosition, newText)
            editingModel.updateSelection(caretPosition, caretPosition + newText.length)

            this.render()
        }
    }

    div.addEventListener("beforeinput", e => {
        if (e.inputType === "deleteByDrag") {
            editingController.handleDeleteByDrag()
        } 
        
        if (e.inputType === "insertFromDrop") {
            newText = e.dataTransfer.getData('text/plain');
            let selection = document.getSelection();
            let caretPosition = selection.anchorOffset;

            editingController.handleInsertFromDrop(newText, caretPosition)
        }
    })
</script></xmp></pre>
            </aside>            

        </section>
    </section>
    <section id="conformance">
        <p>
          This specification defines conformance criteria that apply to a single
          product: the <dfn id="dfn-user-agent">user agent</dfn> that implements the interfaces that
          it contains.
        </p>
        <p>
          Conformance requirements phrased as algorithms or specific steps may be
          implemented in any manner, so long as the end result is equivalent. (In
          particular, the algorithms defined in this specification are intended
          to be easy to follow, and not intended to be performant.)
        </p>
    </section>



    <section data-dfn-for="EditContext">
        <h2>EditContext API</h2>

        <section data-dfn-for="Element">
            <h3>Extensions to the HTMLElement interface</h3>
            <pre class="idl">
               partial interface HTMLElement {
                    attribute EditContext? editContext;
               };
            </pre>
            <dl>
                <dt>editContext</dt>
                <dd>Initially null. The {{HTMLElement/editContext}} getter steps are to return [=this=]'s {{EditContext}} if there is an {{EditContext}} associated.</dd>
                <dd>The {{HTMLElement/editContext}} setter must follow these steps:
                    <div class="algorithm">
                        <dl>
                            <dt>Input</dt>
                            <dd>|editContext|</dd>
                            <dt>Output</dt>
                            <dd>None</dd>
                        </dl>
                    <ol>
                    <li>If |editContext| is null
                        <ol>
                            <li>run [=Detach EditContext=]</li>
                        </ol>
                    </li>
                    <li>Else
                        <ol>
                            <li>run [=Attach EditContext=]</li>
                        </ol>
                    </li>                    
                    </ol>
                    </div><!-- algorithm -->                    
            </dl>
   
            <p>When an element is associated with an {{EditContext}}, it is [=editable=] regardless of whether its [=contentediable=] attribute is true or not.</p>
    
            <p>An element's {{EditContext}} is [=activated=] when the element is [=focused=], and deactivated when the associated element is [=blurred=].</p>
    
            <p>When an {{EditContext}} is [=activated=], the user agent must not modify the DOM when there is user text input from the [=Text Input Service=], instead, the user agent must run [=Update the composition=] if the text input is a composition, and [=Update the text=] if the text input is not a composition.</p>

            <p>When an {{EditContext}} is [=activated=], the user agent must [=Update Text Input Service=] with the current state of the activated {{EditContext}} at least once every frame.</p>

            <p>When an {{EditContext}} is [=activated=], the user agent must [=Modify BeforeInput Event=]'s behavior and must not fire any [=InputEvent=] when there is user text input from the [=Text Input Service=].</p>

            <p>When an element with an associated {{EditContext}} is connected to the tree, the user agent must run [=Connect Element=].</p>

            <p>When an element with an associated {{EditContext}} is disconnected from the tree, the user agent must run [=Disconnect Element=].</p>

                <h4><dfn>Update the composition</dfn></h4>
                <div class="algorithm">
                    <dl>
                        <dt>Input</dt>
                        <dd>|newText|, a string</dd>
                        <dd>|textSpans|, a structure that has text format info</dd>
                        <dd>|newSelectionStart|, the new position for the start of the selection</dd>
                        <dd>|newSelectionEnd|, the new position for the end of the selection</dd>
                        <dt>Output</dt>
                        <dd>None</dd>
                    </dl>
            <ol>
                <li>
                    If |newText| is not empty and [=is composing=] is false
                    <ol>
                        <li>[=Fire an event=] named "compositionstart" at the activated {{EditContext}}.
                        </li>
                        <li>set [=is composing=] to true</li>
                    </ol>
                </li>
                <li>
                    If |newText| is empty and [=is composing=] is false
                    <ol>
                        <li>Return</li>
                    </ol>
                </li>
                <li>
                    If [=composition start=] is 0 and [=composition end=] is 0
                    <ol>
                        <li>Set [=composition start=] to |newSelectionStart|</li>
                        <li>Set [=composition end=] to |newSelectionEnd|</li>
                    </ol>
                </li>
                <li>
                    Replace the substring of [=text=] in the range of [=composition start=] and [=composition end=] with |newText|
                </li>
                <li>Set [=selection start=] to |newSelectionStart|</li>
                <li>Set [=selection end=] to |newSelectionEnd|</li>
                <li>[=Dispatch text update event=] with |newText|</li>
                <li>Set [=composition end=] to [=composition start=] plus the length of |newText|</li>
                <li>[=Dispatch text format update event=] with |textSpans|</li>
                <li>[=Dispatch character bound update event=]</li>
            </ol>
            </div><!-- algorithm -->

            <h4><dfn>Update the text</dfn></h4>
            <div class="algorithm">
                <dl>
                    <dt>Input</dt>
                    <dd>|newText|, a string</dd>
                    <dt>Output</dt>
                    <dd>None</dd>
                </dl>

                <ol>
                    <li>
                        Replace the substring of [=text=] in the range of [=selection start=] and [=selection end=] with |newText|
                    </li>
                    <li>Set [=selection start=] to [=selection start=] plus the length of |newText|</li>
                    <li>Set [=selection end=] to [=selection start=]</li>
                    <li>[=Dispatch text update event=] with |newText|</li>
                </ol>
            </div>

            <h4><dfn>Dispatch text update event</dfn></h4>
        <div class="algorithm">
            <dl>
                <dt>Input</dt>
                <dd>|newText|, a string</dd>
                <dt>Output</dt>
                <dd>None</dd>
            </dl>
    <ol>
        <li>
            Let |event| be a new {{TextUpdateEvent}} with |newText|, [=composition start=], [=composition end=], [=selection start=], and [=selection end=]
        </li>
        <li> [=Fire an event=] named "textupdate" with |event|</li>
    </ol>
    </div><!-- algorithm -->

    <h4><dfn>Dispatch text format update event</dfn></h4>
    <div class="algorithm">
        <dl>
            <dt>Input</dt>
            <dd>|textSpans|, a structure that has text format info</dd>
            <dt>Output</dt>
            <dd>None</dd>
        </dl>
<ol>
    <li>
        Let |event| be a new {{TextFormatUpdateEvent}} with |textSpans|
    </li>
    <li> [=Fire an event=] named "textformateupdate" with |event|</li>
</ol>
</div><!-- algorithm -->

<h4><dfn>Dispatch character bound update event</dfn></h4>
<div class="algorithm">
    <dl>
        <dt>Input</dt>
        <dd>None</dd>
        <dt>Output</dt>
        <dd>None</dd>
    </dl>
<ol>
<li>
    Let |event| be a new {{CharacterBoundsUpdateEvent}} with [=composition start=] and [=composition end=]
</li>
<li> [=Fire an event=] named "characterboundsupdate" with |event|</li>
</ol>
</div><!-- algorithm -->
<h4><dfn>Update Text Input Service</dfn></h4>
<div class="algorithm">
    <dl>
        <dt>Input</dt>
        <dd>None</dd>
        <dt>Output</dt>
        <dd>None</dd>
    </dl>
<ol>
<li>
    <div class="note">Add details</div>
</li>
</ol>
</div><!-- algorithm -->
<h4><dfn>Modify BeforeInput Event</dfn></h4>
<div class="algorithm">
    <dl>
        <dt>Input</dt>
        <dd>None</dd>
        <dt>Output</dt>
        <dd>None</dd>
    </dl>
<ol>
<li>
    <div class="note">Add details</div>
</li>
</ol>
</div><!-- algorithm -->

<h4><dfn>focused</dfn></h4>
<div class="algorithm">
<ol>
<li>
    <div class="note">Add details</div>
</li>
</ol>
</div><!-- algorithm -->

<h4><dfn>blurred</dfn></h4>
<div class="algorithm">
<ol>
<li>
    <div class="note">Add details</div>
</li>
</ol>
</div><!-- algorithm -->

<h4><dfn>Connect Element</dfn></h4>
<div class="algorithm">
<ol>
<li>
    <div class="note">Add details</div>
</li>
</ol>
</div><!-- algorithm -->

<h4><dfn>Disconnect Element</dfn></h4>
<div class="algorithm">
<ol>
<li>
    <div class="note">Add details</div>
</li>
</ol>
</div><!-- algorithm -->

<h4><dfn>Attach EditContext</dfn></h4>
<div class="algorithm">
<ol>
<li>
    <div class="note">Add details</div>
</li>
</ol>
</div><!-- algorithm -->

<h4><dfn>Detach EditContext</dfn></h4>
<div class="algorithm">
<ol>
<li>
    <div class="note">Add details</div>
</li>
</ol>
</div><!-- algorithm -->

        </section>
        <h3 id="editcontext-interface">EditContext Interface</h3>
    <pre class="idl"><xmp>dictionary EditContextInit {
    DOMString text;
    unsigned long selectionStart;
    unsigned long selectionEnd;
};

[Exposed=Window]
interface EditContext : EventTarget {
    constructor(optional EditContextInit options = {});

    undefined updateText(unsigned long rangeStart, unsigned long rangeEnd,
        DOMString text);
    undefined updateSelection(unsigned long start, unsigned long end);
    undefined updateControlBounds(DOMRect controlBounds);
    undefined updateSelectionBounds(DOMRect selectionBounds);
    undefined updateCharacterBounds(unsigned long rangeStart, sequence<DOMRect> characterBounds);

    sequence<Element> attachedElements();

    readonly attribute DOMString text;
    readonly attribute unsigned long selectionStart;
    readonly attribute unsigned long selectionEnd;
    readonly attribute unsigned long compositionRangeStart;
    readonly attribute unsigned long compositionRangeEnd;
    readonly attribute boolean isComposing;
    readonly attribute DOMRect controlBounds;
    readonly attribute DOMRect selectionBounds;
    readonly attribute unsigned long characterBoundsRangeStart;
    sequence<DOMRect> characterBounds();

    attribute EventHandler ontextupdate;
    attribute EventHandler ontextformatupdate;
    attribute EventHandler oncharacterboundsupdate;
    attribute EventHandler oncompositionstart;
    attribute EventHandler oncompositionend;
};</xmp></pre>
        <dl>
            <dt>text</dt>
            <dd>The {{EditContext/text}} getter steps are to return [=this=]'s [=text=].</dd>

            <dt>selectionStart</dt>
            <dd>The {{EditContext/selectionStart}} getter steps are to return [=this=]'s [=selection start=].</dd>

            <dt>selectionEnd</dt>
            <dd>The {{EditContext/selectionEnd}} getter steps are to return [=this=]'s [=selection end=].</dd>

            <dt>compositionRangeStart</dt>
            <dd>The {{EditContext/compositionRangeStart}} getter steps are to return [=this=]'s [=composition start=].</dd>

            <dt>compositionRangeEnd</dt>
            <dd>The {{EditContext/compositionRangeEnd}} getter steps are to return [=this=]'s [=composition end=].</dd>

            <dt>isComposing</dt>
            <dd>The {{EditContext/isComposing}} getter steps are to return [=this=]'s [=is composing=].</dd>

            <dt>controlBounds</dt>
            <dd>The {{EditContext/controlBounds}} getter steps are to return [=this=]'s [=control bounds=].</dd>

<p class="note">
    The control bound may be used by the OS for hittesting to trigger the virtual keyboard.
</p>

            <dt>selectionBounds</dt>
            <dd>The {{EditContext/selectionBounds}} getter steps are to return [=this=]'s [=selection bounds=].</dd>

            <dt>characterBounds</dt>
            <dd>The {{EditContext/characterBounds}} getter steps are to return [=this=]'s [=array of character bounds=].</dd>

            <dt>characterBoundsRangeStart</dt>
            <dd>The {{EditContext/characterBoundsRangeStart}} getter steps are to return [=this=]'s [=character bounds range start=].</dd>

            <dt>updateText() method</dt>
            <dd>
              <p>
                The method must follow these steps:
              </p>
              <div class="algorithm">
                <dl>
                    <dt>Input</dt>
                    <dd>|rangeStart|, an unsigned long</dd>
                    <dd>|rangeEnd|, an unsigned long</dd>
                    <dd>|newText|, a DOMString</dd>
                    <dt>Output</dt>
                    <dd>None</dd>
                </dl>
                <ol>
                    <li>
                        If [=this=] is not activated, abort these steps.
                    </li>
                    <li>
                        Replace the substring of [=text=] in the range of |rangeStart| and |rangeEnd| with |newText|
                    </li>
                    <li>
                        <div class="note">Add details regarding rangeStart/rangeEnd vs. [=selection start=]/[=selection end=]</div>
                    </li>
                </ol>
            </div>
            </dd>
            <dt>updateSelection() method</dt>
            <dd>
                <p>
                  The method must follow these steps:
                </p>
                <div class="algorithm">
                    <dl>
                        <dt>Input</dt>
                        <dd>|start|, an unsigned long</dd>
                        <dd>|end|, an unsigned long</dd>
                        <dt>Output</dt>
                        <dd>None</dd>
                    </dl>
                    <ol>
                        <li>
                            If [=this=] is not activated, abort these steps.
                        </li>
                        <li>
                            If |start| > |end|, abort these steps.
                        </li>
                        <li>
                            set [=selection start=] to |start|
                        </li>
                        <li>
                            set [=selection end=] to |end|
                        </li>
                    </ol>
                </div>
            </dd>
            <dt>updateSelectionBounds() method</dt>
              <dd>
                <p>
                  The method must follow these steps:
                </p>
                <div class="algorithm">
                    <dl>
                        <dt>Input</dt>
                        <dd>|selectionBounds|, a [=DOMRect=]</dd>
                        <dt>Output</dt>
                        <dd>None</dd>
                    </dl>
                    <ol>
                        <li>
                            If [=this=] is not activated, abort these steps.
                        </li>
                        <li>
                            set [=selection bounds=] to |selectionBounds|
                        </li>
                    </ol>
                </div>
              </dd>
              <dt>updateControlBounds() method</dt>
              <dd>
                <p>
                  The method must follow these steps:
                </p>
                <div class="algorithm">
                    <dl>
                        <dt>Input</dt>
                        <dd>|controlBounds|, a [=DOMRect=]</dd>
                        <dt>Output</dt>
                        <dd>None</dd>
                    </dl>
                    <ol>
                        <li>
                            If [=this=] is not activated, abort these steps.
                        </li>
                        <li>
                            set [=control bounds=] to |controlBounds|
                        </li>
                    </ol>
                </div>
              </dd>
              <dt>updateCharacterBounds() method</dt>
              <dd>
                <p>
                  The method must follow these steps:
                </p>
                <div class="algorithm">
                    <dl>
                        <dt>Input</dt>
                        <dd>|rangeStart|, an unsigned long</dd>
                        <dd>|characterBounds|, an array of [=DOMRect=]</dd>
                        <dt>Output</dt>
                        <dd>None</dd>
                    </dl>
                    <ol>
                        <li>
                            If [=this=] is not activated, abort these steps.
                        </li>
                        <li>
                            set [=character bounds range start=] to |rangeStart|.
                        </li>
                        <li>
                            set [=control bounds=] to |controlBounds|.
                        </li>
                    </ol>
                </div>
              </dd>
            <dt>attachedElements() method</dt>
            <dd><p>The method returns elements that are associated with the EditContext.</p></dd>
            <p class="issue">
                should attachedElements() return elements that are removed from the tree? If yes, the EditContext will keep removed elements alive. If not, we probably shouldn't allow a disconnected element to associate with EditContext, otherwise, it would be confusing/unintuitive that we allow it but attachedElements returns empty.
            </p>
            
            <dt>ontextupdate</dt>
            <dd><p>The event handler for {{TextUpdateEvent}}.</p></dd>

            <dt>oncharacterboundsupdate</dt>
            <dd><p>The event handler for {{CharacterBoundsUpdateEvent}}.</p></dd>

            <dt>ontextformatupdate</dt>
            <dd><p>The event handler for {{TextFormatUpdateEvent}}.</p></dd>

            <dt>oncompositionstart</dt>
            <dd><p>The event handler for the <a href='https://w3c.github.io/uievents/#event-type-compositionstart'>compositionstart</a> event.</p></dd>

            <dt>oncompositionend</dt>
            <dd><p>The event handler for the <a href='https://w3c.github.io/uievents/#event-type-compositionend'>compositionend</a> event.</p></dd>
        </dl>
        <section>
            <h3>Supported elements</h3>
            <p>Below is the list of elements that can be associated with {{EditContext}}: abbr, 
                address, 
                article, 
                aside, 
                b, 
                blockquote, 
                canvas, 
                cite, 
                code, 
                del, 
                details, 
                dfn, 
                div, 
                dl, dd, dt,  
                em, 
                footer, 
                form, 
                h1, 
                h2, 
                h3, 
                h4, 
                h5, 
                h6, 
                hgroup, 
                i, 
                ins, 
                kbd, 
                label, 
                mark, 
                object, 
                ol, 
                output, 
                p, 
                pre, 
                q, 
                ruby, 
                s, 
                samp, 
                section, 
                small, 
                span, 
                strong, 
                sub, 
                sup, 
                table, 
                time, 
                u, and
                ul.
                </p>
        </section>

    </section>

    <section data-dfn-for="EditContextEvents">
        <h2>EditContext Events</h2>
        <section>
            <h3>TextUpdateEvent</h3>
            <pre class="idl"><xmp>dictionary TextUpdateEventInit : EventInit {
    unsigned long updateRangeStart;
    unsigned long updateRangeEnd;
    DOMString text;
    unsigned long selectionStart;
    unsigned long selectionEnd;
    unsigned long compositionStart;
    unsigned long compositionEnd;
};

[Exposed=Window]
interface TextUpdateEvent : Event {
    constructor(DOMString type, optional TextUpdateEventInit options = {});
    readonly attribute unsigned long updateRangeStart;
    readonly attribute unsigned long updateRangeEnd;
    readonly attribute DOMString text;
    readonly attribute unsigned long selectionStart;
    readonly attribute unsigned long selectionEnd;
    readonly attribute unsigned long compositionStart;
    readonly attribute unsigned long compositionEnd;
};</xmp></pre>
            <dl>
                <dt>{{TextUpdateEvent/updateRangeStart}}, of type unsigned long, readonly</dt>
                <dd>The start position of the range that is to be replaced.</dd>

                <dt>{{TextUpdateEvent/updateRangeEnd}}, of type unsigned long, readonly</dt>
                <dd>The end position of the range that is to be replaced.</dd>

                <dt>{{TextUpdateEvent/text}}, of type {{DOMString}}, readonly</dt>
                <dd>The new string that is to replace the old string in the range.</dd>

                <dt>{{TextUpdateEvent/selectionStart}}, of type unsigned long, readonly</dt>
                <dd>The start position of the selection after the text replacement.</dd>

                <dt>{{TextUpdateEvent/selectionEnd}}, of type unsigned long, readonly</dt>
                <dd>The end position of the selection after the text replacement.</dd>

                <dt>{{TextUpdateEvent/compositionStart}}, of type unsigned long, readonly</dt>
                <dd>The start position of the composition after the text replacement.</dd>

                <dt>{{TextUpdateEvent/compositionEnd}}, of type unsigned long, readonly</dt>
                <dd>The end position of the composition after the text replacement.</dd>
            </dl>
        </section>
        <section>
            <h3>TextFormatUpdateEvent</h3>
            <pre class="idl"><xmp>dictionary TextFormatInit {
    unsigned long rangeStart;
    unsigned long rangeEnd;
    DOMString textColor;
    DOMString backgroundColor;
    DOMString underlineStyle;
    DOMString underlineThickness;
    DOMString underlineColor;
};

[Exposed=Window]
interface TextFormat {
    constructor(optional TextFormatInit options = {});
    attribute unsigned long rangeStart;
    attribute unsigned long rangeEnd;
    attribute DOMString textColor;
    attribute DOMString backgroundColor;
    attribute DOMString underlineStyle;
    attribute DOMString underlineThickness;
    attribute DOMString underlineColor;
};

dictionary TextFormatUpdateEventInit : EventInit {
    sequence<TextFormat> textFormats;
};

[Exposed=Window]
interface TextFormatUpdateEvent : Event {
    constructor(DOMString type, optional TextFormatUpdateEventInit options = {});
    sequence<TextFormat> getTextFormats();
};</xmp></pre>
            <dl>
                <dt>{{TextFormat/rangeStart}}, of type unsigned long, readonly
                </dt>
                <dd>The start position of the range where the format is applied.
                </dd>
                <dt>{{TextFormat/rangeEnd}}, of type unsigned long, readonly
                </dt>
                <dd>The end position of the range where the format is applied.
                </dd>
                <dt>{{TextFormat/textColor}}, of type {{DOMString}}, readonly
                </dt>
                <dd>The color of the text. The value is a <a href="https://www.w3.org/TR/css-color-4/#serializing-sRGB-values">serialized sRGB values</a>.
                </dd>
                <dt>{{TextFormat/backgroundColor}}, of type {{DOMString}}, readonly
                </dt>
                <dd>The color of the background. The value is a <a href="https://www.w3.org/TR/css-color-4/#serializing-sRGB-values">serialized sRGB values</a>.
                </dd>
                <dt>{{TextFormat/underlineStyle}}, of type {{DOMString}}, readonly
                </dt>
                <dd>The style of the underline. The value is one of the following strings: "None", "Solid", "Dotted", "Dashed", and "Squiggle".
                </dd>
                <dt>{{TextFormat/underlineThickness}}, of type {{DOMString}}, readonly
                </dt>
                <dd>The thickness of the underline. The value is one of the following strings: "None", "Thin", and "Thick".
                </dd>
                <dt>{{TextFormat/underlineColor}}, of type {{DOMString}}, readonly
                </dt>
                <dd>The color of the underline. The value is a <a href="https://www.w3.org/TR/css-color-4/#serializing-sRGB-values">serialized sRGB values</a>.
                </dd>

                <dt>{{TextFormatUpdateEvent/getTextFormats}} method
                </dt>
                <dd>Returns an array of {{TextFormat}} that describes how {{EditContext/text}} should be formatted in the DOM.
                </dd>
            </dl>
        </section>
        <section>
            <h3>CharacterBoundsUpdateEvent</h3>
            <pre class="idl"><xmp>dictionary CharacterBoundsUpdateEventInit : EventInit {
    unsigned long rangeStart;
    unsigned long rangeEnd;
};

[Exposed=Window]
interface CharacterBoundsUpdateEvent : Event {
    constructor(DOMString type, optional CharacterBoundsUpdateEventInit options = {});
    readonly attribute unsigned long rangeStart;
    readonly attribute unsigned long rangeEnd;
};</xmp></pre>
            <dl>
                <dt>{{CharacterBoundsUpdateEvent/rangeStart}}, of type unsigned long, readonly
                </dt>
                <dd>The start position of the range where the character bounds are needed by [=Text Input Service=]
                </dd>
                <dt>{{CharacterBoundsUpdateEvent/rangeEnd}}, of type unsigned long, readonly
                </dt>
                <dd>The end position of the range where the character bounds are needed by [=Text Input Service=]
                </dd>
            </dl>
        </section>
    </section>
    <section>
        <h2>Privacy and Security Considerations</h2>
        <p>To mitigate potential security and privacy risks, browsers are expected to follow best practices described below.</p>
            <p>
                <ul>
                    <li>
                        User Agent MUST only allow {{EditContext/updateSelection()}}, {{EditContext/updateText()}}, {{EditContext/updateSelectionBounds()}}, {{EditContext/updateControlBounds()}}, and {{EditContext/updateCharacterBounds()}} methods to be called in a <a href="https://w3c.github.io/webappsec-secure-contexts/">Secure Context</a>.
                    </li>
                </ul>
            </p>
    </section>
    <section id="idl-index" class="appendix">
        <!-- All the Web IDL will magically appear here -->
    </section>
    <section>
        <h2>Contributors</h2>
        <p class="ednote">
            Add contributors
        </p>
      </section>
      <section id="references" class="appendix"></section>
</body>

</html>
